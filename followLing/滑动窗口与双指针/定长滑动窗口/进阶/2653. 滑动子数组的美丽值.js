/**
 * 给你一个长度为 n 的整数数组 nums ，请你求出每个长度为 k 的子数组的 美丽值 。

一个子数组的 美丽值 定义为：如果子数组中第 x 小整数 是 负数 ，那么美丽值为第 x 小的数，否则美丽值为 0 。

请你返回一个包含 n - k + 1 个整数的数组，依次 表示数组中从第一个下标开始，每个长度为 k 的子数组的 美丽值 。

子数组指的是数组中一段连续 非空 的元素序列。

 

示例 1：

输入：nums = [1,-1,-3,-2,3], k = 3, x = 2
输出：[-1,-2,-2]
解释：总共有 3 个 k = 3 的子数组。
第一个子数组是 [1, -1, -3] ，第二小的数是负数 -1 。
第二个子数组是 [-1, -3, -2] ，第二小的数是负数 -2 。
第三个子数组是 [-3, -2, 3] ，第二小的数是负数 -2 。
示例 2：

输入：nums = [-1,-2,-3,-4,-5], k = 2, x = 2
输出：[-1,-2,-3,-4]
解释：总共有 4 个 k = 2 的子数组。
[-1, -2] 中第二小的数是负数 -1 。
[-2, -3] 中第二小的数是负数 -2 。
[-3, -4] 中第二小的数是负数 -3 。
[-4, -5] 中第二小的数是负数 -4 。
示例 3：

输入：nums = [-3,1,2,-3,0,-3], k = 2, x = 1
输出：[-3,0,-3,-3,-3]
解释：总共有 5 个 k = 2 的子数组。
[-3, 1] 中最小的数是负数 -3 。
[1, 2] 中最小的数不是负数，所以美丽值为 0 。
[2, -3] 中最小的数是负数 -3 。
[-3, 0] 中最小的数是负数 -3 。
[0, -3] 中最小的数是负数 -3 。
 */

const getSubarrayBeauty = function (nums, k, x) {
  const BIAS = 50 // 偏移量，将 [-50, 50] 映射到 [0, 100]
  const cnt = new Array(BIAS * 2 + 1).fill(0) // 计数数组
  
  // 先往窗口内添加 k-1 个数
  for (let i = 0; i < k - 1; i++) {
    cnt[nums[i] + BIAS]++
  }
  
  const n = nums.length
  const ans = new Array(n - k + 1)
  
  for (let i = k - 1; i < n; i++) {
    cnt[nums[i] + BIAS]++ // 进入窗口（保证窗口有恰好 k 个数）
    
    // 寻找第 x 小的负数
    let left = x
    for (let j = 0; j < BIAS; j++) { // 暴力枚举负数范围 [-50, -1]
      left -= cnt[j]
      if (left <= 0) { // 找到美丽值
        ans[i - k + 1] = j - BIAS
        break
      }
    }
    // 如果没找到（left > 0），说明负数不足 x 个，美丽值为 0（ans 初始化时已经是 0）
    
    cnt[nums[i - k + 1] + BIAS]-- // 离开窗口
  }
  
  return ans
}

// 测试用例
console.log("示例1:", getSubarrayBeauty([1, -1, -3, -2, 3], 3, 2)); // 预期输出: [-1,-2,-2]
console.log("示例2:", getSubarrayBeauty([-1, -2, -3, -4, -5], 2, 2)); // 预期输出: [-1,-2,-3,-4]
console.log("示例3:", getSubarrayBeauty([-3, 1, 2, -3, 0, -3], 2, 1)); // 预期输出: [-3,0,-3,-3,-3]